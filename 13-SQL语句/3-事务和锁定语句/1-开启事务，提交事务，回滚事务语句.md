```sql
START TRANSACTION
    [transaction_characteristic [, transaction_characteristic] ...]

transaction_characteristic: {
    WITH CONSISTENT SNAPSHOT
  | READ WRITE
  | READ ONLY
}

BEGIN [WORK]
COMMIT [WORK] [AND [NO] CHAIN] [[NO] RELEASE]
ROLLBACK [WORK] [AND [NO] CHAIN] [[NO] RELEASE]
SET autocommit = {0 | 1}
```

These statements provide control over use of transactions:

这些语句提供了对事务使用的控制：

* START TRANSACTION or BEGIN start a new transaction.

  START TRANSACTION 或者 BEGIN 开启一个新的事务。

* COMMIT commits the current transaction, making its changes permanent.

  COMMIT 提交当前事务，使当前事务的改变持久化。

* ROLLBACK rolls back the current transaction, canceling its changes.
  * ROLLBACK 回滚当前事务，取消当前事务的改变。

* SET autocommit disables or enables the default autocommit mode for the current session.
  * SET 为当前事务设置默认的自动提交模式（停用或者启用）

By default, MySQL runs with autocommit mode enabled. This means that, when not otherwise inside a transaction, each statement is atomic, as if it were surrounded by START TRANSACTION and COMMIT. You cannot use ROLLBACK to undo the effect; however, if an error occurs during statement execution, the statement is rolled back.

默认情况下，MySQL 运行的时候启用自动提交模式。这意味着，每个语句（不在一个事务内）都是原子的，就好像该语句被 START TRANSACTION 和 COMMIT 包围一样。因此不能使用 ROLLBACK 来撤销语句的生效，如果语句在执行期间发生了错误，那么语句将会回滚。

To disable autocommit mode implicitly for a single series of statements, use the START TRANSACTION statement:

对于单个语句系列，使用 START TRANSACTION 语句，隐式地停用自动提交模式：

```sql
START TRANSACTION;
SELECT @A:=SUM(salary) FROM table1 WHERE type=1;
UPDATE table2 SET summary=@A WHERE type=1;
COMMIT;
```

With START TRANSACTION, autocommit remains disabled until you end the transaction with COMMIT or ROLLBACK. The autocommit mode then reverts to its previous state.

随着 START TRANSACTION，自动提交一直停用直到通过 COMMIT 或者 ROLLBACK 结束事务。自动提交模式将恢复到其之前的状态。

START TRANSACTION permits several modifiers that control transaction characteristics. To specify multiple modifiers, separate them by commas.

START TRANSACTION 允许控制事务特性的多个修饰符。指定不同的修饰符，需要使用逗号分隔。

* The WITH CONSISTENT SNAPSHOT modifier starts a consistent read for storage engines that are capable of it. This applies only to InnoDB. The effect is the same as issuing a START TRANSACTION followed by a SELECT from any InnoDB table. See Section 15.7.2.3, “Consistent Nonlocking Reads”. The WITH CONSISTENT SNAPSHOT modifier does not change the current transaction isolation level, so it provides a consistent snapshot only if the current isolation level is one that permits a consistent read. The only isolation level that permits a consistent read is REPEATABLE READ. For all other isolation levels, the WITH CONSISTENT SNAPSHOT clause is ignored. A warning is generated when the WITH CONSISTENT SNAPSHOT clause is ignored.

  WITH CONSISTENT SNAPSHOT 修饰符对于适用的存储引擎开启读一致性。仅应用于 InnoDB。其效果与启动一个 START TRANSACTION，然后从任何 InnoDB 表中执行 SELECT 是一样的。参考章节 15.7.2.3 非锁读一致性。WITH CONSISTENT SNAPSHOT 修饰符并不会改变当前事务的隔离水平，因此它仅仅在当前事务隔离水平允许读一致性时才会提供一个一致性快照。唯一一个提供读一致性的隔离水平是 REPEATABLE READ。对于其他的隔离水平，WITH CONSISTENT SNAPSHOT 语句将会忽视。当 WITH CONSISTENT SNAPSHOT 语句被忽视将会生成一个警告。

* The READ WRITE and READ ONLY modifiers set the transaction access mode. They permit or prohibit changes to tables used in the transaction. The READ ONLY restriction prevents the transaction from modifying or locking both transactional and nontransactional tables that are visible to other transactions; the transaction can still modify or lock temporary tables.

  READ WRITE 和 READ ONLY 修饰符设置事务的访问模式。他们允许或者禁止更新事务中使用的表。READ ONLY 限制可防止事务修改或者锁定对其他事务可见的事务表和非事务表；事务仍然可以修改或者锁定临时表。

  MySQL enables extra optimizations for queries on InnoDB tables when the transaction is known to be read-only. Specifying READ ONLY ensures these optimizations are applied in cases where the read-only status cannot be determined automatically. See Section 8.5.3, “Optimizing InnoDB Read-Only Transactions” for more information.

  MySQL 对于 InnoDB 表当事务是 read only，将启用额外的查询优化。指定 READ ONLY 可确保在无法自动确定只读状态的情况下，这些优化能被应用。参考章节 8.5.3，优化 InnoDB 只读事务获取更多信息。

  If no access mode is specified, the default mode applies. Unless the default has been changed, it is read/write. It is not permitted to specify both READ WRITE and READ ONLY in the same statement.

  如果没有访问模式被指定，默认访问模式将会起作用。默认的访问模式是 read/write，除非默认访问模式被修改了。不允许在同一个语句中同时指定 READ WRITE 和 READ ONLY。

  In read-only mode, it remains possible to change tables created with the TEMPORARY keyword using DML statements. Changes made with DDL statements are not permitted, just as with permanent tables.

  在 read-only 模式中，仍然可以修改使用 TEMPORARY 关键词创建的表（DML 语句）。DDL 语句相关的修改不被允许，就像永久表。

  For additional information about transaction access mode, including ways to change the default mode, see Section 13.3.7, “SET TRANSACTION Statement”.

  获取事务访问模式更多的信息，包括修改默认访问模式的方式，参考章节 13.3.7 设置事务语句。

  If the read_only system variable is enabled, explicitly starting a transaction with START TRANSACTION READ WRITE requires the CONNECTION_ADMIN privilege (or the deprecated SUPER privilege).

  如果 read_only 系统变量被启用，START TRANSACTION READ WRITE 显示开启一个事务需要 CONNECTION_ADMIN 权限（或者被废弃的 SUPER 权限）。

  >Important
  >Many APIs used for writing MySQL client applications (such as JDBC) provide their own methods for starting transactions that can (and sometimes should) be used instead of sending a START TRANSACTION statement from the client. See Chapter 29, Connectors and APIs, or the documentation for your API, for more information.
  >
  >重要

To disable autocommit mode explicitly, use the following statement:

显示的禁用自动提交模式，使用以下的语句：

```sql
set autocommit = 0
```

After disabling autocommit mode by setting the autocommit variable to zero, changes to transaction-safe tables (such as those for InnoDB or NDB) are not made permanent immediately. You must use COMMIT to store your changes to disk or ROLLBACK to ignore the changes.

在通过设置自动提交变量为零以禁用自动提交模式之后，对于事务安全的表（比如 InnoDB 或者 NDB）的修改将不会立即持久化。必须使用 COMMIT 来将改变存储到磁盘中，或者使用 ROLLBACK 忽视改变。

autocommit is a session variable and must be set for each session. To disable autocommit mode for each new connection, see the description of the autocommit system variable at Section 5.1.8, “Server System Variables”.

自动提交是一个 session 变量，必须为每一个 session 设置。为了对于每一个新的 session 都禁用自动提交模式，参考章节 5.1.8 关于自动提交服务器变量的描述，“服务器系统变量”。

BEGIN and BEGIN WORK are supported as aliases of START TRANSACTION for initiating a transaction. START TRANSACTION is standard SQL syntax, is the recommended way to start an ad-hoc transaction, and permits modifiers that BEGIN does not.

BEGIN 和 BEGIN WORK 是 START TRANSACTION 的别名，也可以用来开启一个事务。START TRANSACTION 是 SQL 标准语法，也是开启一个 ad-hoc（不知道啥含义） 事务的推荐方式，当 BEGIN 修饰符不被允许。

The BEGIN statement differs from the use of the BEGIN keyword that starts a BEGIN ... END compound statement. The latter does not begin a transaction. See Section 13.6.1, “BEGIN ... END Compound Statement”.

BEGIN 语句不同于使用 BEGIN 关键词开启的 BEGIN ... END 复合语句。后者并不会开启一个事务。参考章节 13.6.1 BEGIN ... END 复合语句。





























